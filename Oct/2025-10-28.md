## 📆 2025-10-28

### 🔔 스크럼

- 브라우저 저장소 강의 복습 및 정리
- jwt 구조 고민 및 환경구성

  - access, refresh 둘다 쿠키로 결정
  - 토큰 DB 생성
  - config, filter 등 파일 구조 고민하여 필요한 파일들 생성 및 코드작성

- 로그인 부분 jwt로 바꿈
  - 백엔드 API 수정(토큰 발급, 유효성 검사 등)
  - 프론트 서버쪽 수정

### 🚀 Today I Learned

#### 브라우저 저장소

- **Storage**
- **Cookie**
- IndexedDB

#### Storage

- 컴퓨터에서 데이터를 일시적으로, 또는 영구히 보존하는 장치
- Why? 데이터를 안전하게 보관하고, 언제든지 쉽게 찾아서 사용할 수 있도록 하기위함
- 브라우저 스토리지 : 브라우저에 저장되는 **데이터 저장소**.
  - Local Storage : (도메인별) 브라우저 로컬에 저장되는 스토리지
    - 브라우저 탭을 닫아도 데이터 유지, **js접근 가능,** 서버로 자동 전송되지 않음
    - 유효기간 : 반영구적
  - Session Storage : 브라우저 탭 세션 단위로 저장되는 스토리지(도베메인별 + 탭별)
    - 탭 닫으면 데이터 자동삭제, **js접근 가능,** 서버로 자동 전송되지 않음
    - 유효기간 : 세션동안

#### Cookie

- 사용목적
  - 세션관리 : 서버에 저장해야할 로그인, 장바구니 등 세션 정보 관리
  - 개인화 : 사용자 선호, 테마 등의 설정
  - 트래킹 : 사용자 행동 기록 분석 등
- 동작방식(기본 방식)
  - 쿠키는 서버에서 브라우저에 발급하고, 브라우저는 서버에 요청시, **조건에 따라** 쿠키를 **자동 포함**하여 전달한다.
  - 자동 전송이 기본인데, 조건에 따라 자동 전송 → 핸들링하는게 어려움
- 만드는법
  - 서버에서 쿠키 발급하기(response) : Set-Cookie
  - 클라이언트에서 쿠키 포함(reqeust) : Cookie 헤더
- 생명주기
  - 세션 쿠키 : 쿠키 속성 중, 만료 기한이 없는 쿠키들 → 세션 종료시 삭제
  - 영속 쿠키 : Expires, Max-Age 속성이 있는 쿠키 → 명시된 기간 이후 삭제
- **Cookie 보안 처리**
  - 쿠키는 클라이언트에 있고 전송할때마다 같이 전송됨. 위험한데?
  - Secure 속성
    - HTTPS 프로토콜에서만 전송되는 쿠키
    - HTTP에서는 전송되지 X
    - 전송단 암호화는 HTTPS에서 책임지지만, 쿠키 그 자체가 암호화되는 것은 X → 실질적 보안 제공X
    - 거의 항상 사용함. 서버에서 만들때 속성 추가
  - SameSite 속성
    - CSRF 공격을 방지하기 위한 속성
      - CSRF : 브라우저가 자동으로 쿠키를 보내는 특성을 악용하는 방법
    - Strict, Lax, None 등의 옵션으로 지정
    - 도메인이 동일한지, 요청이 GET,PUT 등 어떤건지
    - 쿠키를 허용한 도메인, 허용한 요청에만 포함하도록 하는 속성
  - HttpOnly 속성
    - Cross-site 스크립팅 방지를 위한 속성(XSS)
    - 쿠기에 해당 속성있으면 js에서 접근X
    - 이 속성이 붙은 쿠키는 전송될때만 사용, 즉 HTTP 요청일 때만 전송
- **Cookie 스코프**
  - 어떤 URL 요청에 쿠키를 포함하게 할건지
  - Domain
    - 쿠키가 전송되게 할 호스트
    - 명시되지 않으면 현재 호스트 일부 갑을 기본으로 설정
    - 정의된 도메인일때, 쿠키는 요청에 자동 포함되어 전송
  - Path
    - 쿠키 전송제어를 일부 할 수 있음
    - 쿠키를 전송하기 위해, URL 중 포함되어야 하는 경로
    - Path=/docs로 설정되면 /docs, /docs/web 등에서 쿠키가 포함됨

#### HTTP 자격증명 헤더

- 클라이언트와 서버간의 인증과정에서 사용자의 자격을 확인하기 위해 사용되는 헤더
- HTTP Authorization 헤더에 인코딩된 인증정보를 담아, 요청과 함꼐 서버로 전송
- 방식
  - 기본인증 → 잘사용X
  - 다이제스트 인증 → 잘사용X
    - 기본인증은 인코딩하는데, 얘는 인증정보를 해싱
  - **Bearer토큰**
    - JWT 같은 토큰 지원
    - 토큰을 이용한 인증에서 사용
  - OAuth

#### JWT의 Access Refresh Token은 각각 어디에서 관리하는게 좋을까? = 인증/인가 설계

- 가정 ㅣAT는 클라이언트에서 관리한다
  - 로컬 스토리지 ⇒ 할수는 있지만 보안적인 이슈로 잘 안함
    - js 접근가능(탈취쉬움)
    - setm,getItem으로 개발자가 관리해줘야함
  - 세션 스토리지
  - 쿠키 ⇒ AT는 여기에 안넣음!
    - 문제점
      - js 접근 가능 → HttpOnly로 해결가능
      - 요청시 자동 포함 → 해결불가!! 쿠키제어 힘듬!!
      - 길이 제한
      - 항상 통신할때 전달됨
- **AT는 보통 인메모리(브라우저 JS 메모리 내)에서 관리함.**
  - MPA에서는 불가. 보통 React같은 SPA형식에서 사용함
  - HTTP 자격증명 헤더에다가 js로 가져와서
- **RT는 보통 쿠키에 저장함**
  - 보안을 위해
    - HTTPOnly 사용
    - Secure 사용
  - 브라우저 자동전송 문제는?
    - 그냥 놔둘수도 있고
      - 장점1 : AT 만료시, 처리간편
    - Scope Domain/Path 지정
      - API 왔다갔다 겁나해야함
- 개발편의성과 보안은 반비례! 내가 만드는 사이트가 얼만큼의 보안을 신경쓸건지에 따라 정하면됨

### 🔥 오늘의 도전 과제와 해결 방법

- 개인프로젝트는 MPA형식이라 토큰 저장방식이 고민하다가 아래와 같이 결정내림
  - **access : 인메모리 → 세션스토리지 → 쿠키**
    - 인메모리 하려고 했으나 프론트 구조가 MPA라 페이지 이동할때마다 access token이 사라지는 이슈를 발견하여 아래와 같이 시도함
    - 그렇다면 일단 세션스토리지에 저장해놓고, 공통 js를 로드시켜 세션스토리지에 담아놨던 토큰을 인메모리형식으로 저장 → 뭔가 억지로 공통 js를 타게하는것 같고, 타이밍 잘못맞추면 페이지 이동시 바로 fetch타는 애들이랑 안맞겠다 싶어서 아래와 같이 결정
    - 결국 쿠키(HttpOnly) 사용으로 결정 → 여러모로 내가 구현한 구조(MPA가 서버가 라우팅을 담당하고 페이지 전환이 실제 HTTP 요청)와 잘맞는다고 생각 : fetch안타는 페이지 이동시에도 쿠키가 자동 유지되고 백으로 전송되고, js로 접근도 못함
- **refresh : DB + 쿠키**
  - 위와 같은 이유로 refresh토큰도 쿠키에다가 저장을 했고, 내 커뮤니티는 로그인을 해야만 모든 페이지를 볼 수 있는 폐쇄형 커뮤니티여서 보안성을 조금이라도 높이기 위해 DB에다가도 저장을 해서 클라이언트가 가지고 있는 토큰이 유효한지를 한번더 체크할 수 있도록 함

### 🗨️ 오늘의 회고

- 오늘 일과의 대부분은 토큰 저장위치를 고민하면서 이것저것 시도하는 과정과 내 프로젝트에 맞는걸 찾아가는 과정이었다. 학습만 했다면 와닿지 않았을 것 같은데, 코드를 짜고, 오류를 마주하고 해결하는 과정을 통해 기억에 많이 남을 것 같다.
