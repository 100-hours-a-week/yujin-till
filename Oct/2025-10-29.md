## 📆 2025-10-29

### 🔔 스크럼

- 필터와 인터셉트 강의 복습 및 정리
- 7주차 과제 2번(JWT로 마이그레이션) 80% 완료하기
  - refresh 발급하는 부분 프론트, 백엔드 구현
  - 페이지 이동시 로그인 확인하는 부분(프론트) 구현
  - 모든 API 탈때 토큰 검사하는 로직 확인

### 🚀 Today I Learned

#### 서블릿과 Spring MVC

- 서블릿 : 자바를 사용해, 웹페이지를 동적으로 생성하는 프로그램
- 서블릿 컨테이너 : 서블릿을 담아두고 관리하는 주체
- Dispatcher Servelet : Spring MVC의 프론트 컨트롤러 역할
- ⇒ 스프링은 Web MVC와 디스패쳐 서블릿을 사용함으로서 개발자는 구현로직에만 집중할 수 있음

#### 필터

- 서블릿 컨테이너가 디스패처 서블릿 요청 전달 전/후 URL패텬에 맞는 모든 요청에 대한 부가처리
- 특징
  - 서블릿, 정적 컨텐츠에 대한 요청이나 응답에 필터링 작업하는 객체
  - 서블릿 컨테이너가 제공하는 기능(톰캣 등)
  - 스프링 프레임워크와 무관하게 작동가능(스프링 프레임워크 들어가기 전에 있는거라)
  - 필터는 필터체인으로 구성
- 주요 용도
  - 공통 보안, 인증/인가 작업
  - 모든 요청에 대한 로깅, 감사
    - 모든 요청 = 정적컨텐츠, 라우팅. 리다이랙션, API요청 등
  - 이미지 데이터 압축 및 문자열 인코딩
  - 스프링과 분리되어야 하는 기능
- 필터 메소드
  - init
    - 필터 객체 초기화
    - 웹컨테이너가 1회 호출함
    - 아직은 추가할거 없을듯? 필터 자원필요할때 쓰임
  - doFilter
    - URL 패턴이 맞는 모든 요청이 디스패처 서블릿에 전달되기 전 실행
    - 파라미터에 FilterChain이있음
    - 필터 체인에 doFilter로 다음 대상으로 요청 전달
      - 필터가 실패해서 요청전달하지 않을때는 안써도 되지만, 그렇지 않을때는 꼭 써줘야함
  - destroy()
    - 필터 객체를 서비스에서 제거하기
    - 필터에서 사용했던 자원을 반환하는 등 동작 정의
    - 웹 컨테이너에 의해 1번 호출, 더이상 doFilter에 의해 처리X
- 필터 체인
  - 서브릿 컨테이너가 관리하는 필터들의 연결고리
  - 디스패처 서블릿 도착 전, 필요한 여러 필터를 순차적을 거치도록
  - 필더 등록 순서에 따라 순차 처리 순서 설정
  - 각필터에서 doFilter() 호출로 다음 필터 호출
- 문제 발생!!
  - 서블릿 컨테이너는 스프링 내부 영역이 아님. 필터에서도 DI 같은 스프링 기술 필요
  - → DelegatingFilterProxy 생김
    - 서블릿 컨테이너에서 관리되는 프록시용 필터(가짜 필터)
    - 우리가 만든 필터 갖고있음
    - 요청이 오면 우리가 만든 필터에게 요청 위임
    - spring boot에서는 이 개념이 추상화됨 → 톰캣 내장으로 들어감
- 요청 처리 흐름
  - 클라이언트 → 필터 in 서블릿 컨텍스트 → 디스패처 서블릿 in 스프링 컨텍스트→( 인터셉터 in 스프링 컨텍스트) → 컨트롤러 in 스프링 컨텍스트

#### 인터셉터

- 디스패처 서블릿이 컨트롤러 호출 전/후 호출되는 기능
- 거쳐야하면 거치고 아니면 패스할 수 있음
- 특징
  - 스프링이 제공하는 기술
  - 디스패터 서블릿이 컨트롤러 호출 전,후 호출
  - 요청과 응답을 참조,가공하는 기능
  - 스프링 컨텍스트에서 동작 제공 → 톰캣이 제공하는거 못함
- 주요 용도
  - 세부적인 보안,인증/인가 작업
  - API 호출에 대한 별도 로깅 또는 감사해야할때
  - 컨트롤러로 넘겨주는 정보 가공
- 메소드

  - preHandle
    - 컨트롤러 호출 전 실행, 컨트롤러 이전에 처리해야하는 전처리
    - 요청 정보를 가공,추가하는 경우
    - 반환 타입은 boolean(true : 다음 엔터셉터 혹은 컨트롤러, false: 작업 중지)
    - 보통 여기서 많이 핸들링함
  - postHandle
    - 컨트롤러 호출 후 실행, 컨트롤러 이후 처리해야하는 후처리
    - 컨트롤러 반환 값 타입 정보 제공
    - 컨트롤러 하위에서 예외 발생시 호출되지 않음
    - 요새는 많이 사용안함
  - afterCompletion
    - 모드 작업이 완료된 후 실행
    - 요청 처리중 사용한 리소스 반환 등
    - 요청중, 예외 발생되더라고 반드시 afterCompletion 호출

- Req, Res가 뭘까?
  - doFilter(SeveletRequest request, ServletResponse response,…) 보통 이렇게 받는데, request, response대신에 new MockRequest()같은 객체같은거 넣어도 된다는 의미!

#### 그렇다면 AOP와 필터, 인터셉트 뭐가 다를까?

- 필터 : 전역 로직(인코딩, XSS필터링 등)
- 인터셉터 : 컨트롤러 관련 로직(요청별 공통 데이터 주입 등), AOP만큼은 컨트롤불가
- AOP : 스프링 빈 메서드 관련 로직(트랜잭션 등), 자세하게 컨트롤가능

#### 인증/인가와 필터, 인터셉트

- 어디에서 구현하는게 좋을까? → 정답은 없음. 각각의 장단점 있음
  - 찰리식
    - 필터 - 인증용 코드(jwt토큰을 까는 역할만)
    - 인터셉터 - 인가용
    - 로깅용 AOP
  - 유진식
    - 내 커뮤니티에는 아직 권한 구현이 안되어 있어서 필터만 구현
    - 필터에서 토큰 유효검사하고 통과할시 memberId를 request에 담아서 이후 API에서 공통으로 사용될 수 있도록 구현함

### 🔥 오늘의 도전 과제와 해결 방법

- 프론트 페이지 접근권한시 토큰만 확인하면 될까? 토큰 유뮤만 확인하면 될까?
  - 세션으로 로그인여부 관리했을때는 매번 페이지 이동할때마다 세션참고해서 했었는데, jwt로 바꾸면서 프론트딴에서는 단순히 쿠키에 토큰값들이 있냐없냐만 확인함.
  - 그 이유는 백엔드쪽에서 권한처리를 하려고 보면, fetch를 통해 백엔드쪽으로 넘어와야만 검사를 할 수 있음 → 근데, 로그인/회원가입 등 페이지 입장과 동시에 fetch가 되지 않는 페이지들은 프론트에서 검사를 해야한다고 생각함 → app.js에다가 쿠키의 토큰여부만 파악해서 로그인했으면 로그인관련페이지 못들어가게, 로그인안햇으면 다른 페이지들은 못들어가게함 → 토큰의 유효성 검사는 어짜피 fetch할때 검사하니까 페이지 이동시마다 또 fetch를 보내는건 아닌거 같아서 단순 쿠키 조회만으로 판단하기로함

### 🗨️ 오늘의 회고

- 문제를 마주치고 해결하는 과정에서 많이 배우는 것 같다. 항상 헷갈리는 것은 내 결정이 옳은것인가..!에 대해서도 고민이 된다.
